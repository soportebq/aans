<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=1.0, maximum-scale=3.0">
    <title>DBSCAN Pregunta 8: Complejidad Temporal</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <link rel="stylesheet" href="dbscan.css">
</head>
<body>
    <div class="container">
        <div class="header q8">
            <h1>DBSCAN: Pregunta 8</h1>
            <p>¬øCu√°l es la Complejidad Temporal del Algoritmo DBSCAN?</p>
        </div>
        
        <div class="content">
            <div class="question-box q8">
                <h2>¬øCu√°l es la complejidad temporal del algoritmo DBSCAN?</h2>
                <p><strong>Contexto:</strong> La complejidad temporal determina qu√© tan eficiente es el algoritmo conforme aumenta el tama√±o del dataset y depende de las estructuras de datos utilizadas.</p>
                <ul>
                    <li><strong>Implementaci√≥n naive:</strong> O(N¬≤) sin estructuras auxiliares</li>
                    <li><strong>Implementaci√≥n optimizada:</strong> O(N log N) con √≠ndices espaciales</li>
                    <li><strong>Factores determinantes:</strong> Estructura de datos, distribuci√≥n, par√°metros</li>
                </ul>
            </div>

            <div class="answer-section">
                <h3>Respuesta: La complejidad temporal var√≠a seg√∫n la implementaci√≥n</h3>
                
                <h4>Complejidades seg√∫n implementaci√≥n:</h4>
                <p><strong>Mejor caso:</strong> O(N log N) con estructuras de indexaci√≥n espacial (KD-tree, R-tree)</p>
                <p><strong>Caso promedio:</strong> O(N log N) en implementaciones modernas optimizadas</p>
                <p><strong>Peor caso:</strong> O(N¬≤) sin estructuras de indexaci√≥n o con datos degenerados</p>
                
                <h4>Factores determinantes:</h4>
                <p>La eficiencia depende cr√≠ticamente de la <strong>estructura de indexaci√≥n</strong> utilizada para las consultas de vecindario, la <strong>distribuci√≥n de los datos</strong>, y los <strong>valores de los par√°metros</strong> Œµ y MinPts.</p>
            </div>

            <div class="demo-section">
                <h3>üî¨ Demostraci√≥n Interactiva: Impacto de la Complejidad</h3>
                <p><strong>Experimenta con diferentes tama√±os de dataset y observa el impacto dram√°tico:</strong></p>
                
                <div class="controls-container">
                    <div class="control-group">
                        <label for="dataset-size">Tama√±o del Dataset: <span id="size-value">500</span> puntos</label>
                        <input type="range" id="dataset-size" min="100" max="5000" value="500" step="100">
                    </div>
                    
                    <div class="control-group">
                        <label for="implementation-type">Implementaci√≥n:</label>
                        <select id="implementation-type">
                            <option value="indexed">Con √çndice Espacial - O(N log N)</option>
                            <option value="naive">Sin √çndice (Naive) - O(N¬≤)</option>
                        </select>
                    </div>
                    
                    <div class="control-group">
                        <label for="eps-slider">Epsilon: <span id="eps-value">40</span></label>
                        <input type="range" id="eps-slider" min="20" max="80" value="40" step="10">
                    </div>
                </div>
                
                <svg id="complexity-demo" width="650" height="400"></svg>
                
                <div class="results-info">
                    <div class="result-item">
                        <strong>Puntos (N):</strong> <span id="current-size">500</span>
                    </div>
                    <div class="result-item">
                        <strong>Complejidad:</strong> <span id="complexity-order">O(N log N)</span>
                    </div>
                    <div class="result-item">
                        <strong>Operaciones Est.:</strong> <span id="estimated-ops">4,500</span>
                    </div>
                    <div class="result-item">
                        <strong>Tiempo Est.:</strong> <span id="execution-time">45ms</span>
                    </div>
                    <div class="result-item">
                        <strong>Memoria Est.:</strong> <span id="memory-usage">2.4MB</span>
                    </div>
                    <div class="result-item">
                        <strong>Escalabilidad:</strong> <span id="scalability-rating">Excelente</span>
                    </div>
                </div>
            </div>

            <div class="comparison-section base-card">
                <h3>üìä Comparaci√≥n Visual de Complejidades</h3>
                <svg id="complexity-comparison" width="650" height="300"></svg>
                <p><small>Gr√°fico mostrando c√≥mo escala cada implementaci√≥n con el tama√±o del dataset. La diferencia se vuelve dram√°tica con datasets grandes.</small></p>
            </div>

            <div class="complexity-grid">
                <div class="complexity-card best-case base-card">
                    <h4>üü¢ Mejor Caso: O(N log N)</h4>
                    <div class="formula-display">
                        O(N log N)
                    </div>
                    <p><strong>Condiciones requeridas:</strong></p>
                    <ul>
                        <li>Uso de √≠ndices espaciales (KD-tree, R-tree)</li>
                        <li>Consultas de vecindario en tiempo logar√≠tmico</li>
                        <li>Datos bien distribuidos en el espacio</li>
                        <li>Implementaci√≥n optimizada profesional</li>
                        <li>Par√°metros balanceados (Œµ moderado)</li>
                    </ul>
                    <p><strong>Escenario ideal:</strong> Datasets grandes con distribuci√≥n espacial uniforme y librer√≠as optimizadas como scikit-learn.</p>
                </div>

                <div class="complexity-card worst-case base-card">
                    <h4>üî¥ Peor Caso: O(N¬≤)</h4>
                    <div class="formula-display">
                        O(N¬≤)
                    </div>
                    <p><strong>Condiciones que lo causan:</strong></p>
                    <ul>
                        <li>Sin estructuras de indexaci√≥n espacial</li>
                        <li>B√∫squeda de vecinos brute-force</li>
                        <li>Datos degenerados o mal distribuidos</li>
                        <li>Implementaci√≥n naive sin optimizaciones</li>
                        <li>Epsilon muy grande (muchos vecinos)</li>
                    </ul>
                    <p><strong>Escenario problem√°tico:</strong> Implementaciones caseras sin conocimiento de algoritmos de indexaci√≥n espacial.</p>
                </div>

                <div class="complexity-card average-case base-card">
                    <h4>üü° Caso Pr√°ctico: O(N log N)</h4>
                    <div class="formula-display">
                        O(N log N)
                    </div>
                    <p><strong>Implementaciones modernas:</strong></p>
                    <ul>
                        <li>Scikit-learn: Autom√°ticamente optimizada</li>
                        <li>WEKA: Incluye √≠ndices espaciales</li>
                        <li>R (dbscan): Implementaci√≥n eficiente</li>
                        <li>Spark MLlib: Paralelizada y optimizada</li>
                        <li>Bibliotecas especializadas en clustering</li>
                    </ul>
                    <p><strong>Escenario real:</strong> La mayor√≠a de aplicaciones pr√°cticas logran complejidad logar√≠tmica con herramientas modernas.</p>
                </div>
            </div>

            <div class="factors-grid">
                <div class="factor-card indexing-factor base-card">
                    <h4>üå≥ Estructuras de Indexaci√≥n Espacial</h4>
                    
                    <h5>KD-Tree (K-Dimensional Tree):</h5>
                    <ul>
                        <li>B√∫squeda de vecinos en O(log N)</li>
                        <li>Eficiente para dimensiones bajas (2D-6D)</li>
                        <li>Rendimiento degrada en alta dimensionalidad</li>
                        <li>Ideal para datos geogr√°ficos y espaciales</li>
                    </ul>
                    
                    <h5>R-Tree (Rectangle Tree):</h5>
                    <ul>
                        <li>Optimizado para consultas geom√©tricas</li>
                        <li>Excelente para datos geogr√°ficos</li>
                        <li>Maneja regiones rectangulares eficientemente</li>
                        <li>Usado en sistemas GIS profesionales</li>
                    </ul>
                    
                    <h5>Ball-Tree:</h5>
                    <ul>
                        <li>Eficiente en alta dimensionalidad</li>
                        <li>Usa m√©tricas de distancia generalizadas</li>
                        <li>Mejor que KD-tree para >10 dimensiones</li>
                        <li>Implementado en scikit-learn</li>
                    </ul>
                </div>

                <div class="factor-card distribution-factor base-card">
                    <h4>üìà Distribuci√≥n de Datos</h4>
                    
                    <h5>‚úÖ Distribuciones Favorables:</h5>
                    <ul>
                        <li><strong>Uniforme:</strong> √çndices espaciales muy eficientes</li>
                        <li><strong>Clusters separados:</strong> Consultas r√°pidas</li>
                        <li><strong>Baja dimensionalidad:</strong> KD-tree optimal</li>
                        <li><strong>Densidad moderada:</strong> Balance ideal</li>
                    </ul>
                    
                    <h5>‚ùå Distribuciones Problem√°ticas:</h5>
                    <ul>
                        <li><strong>Muy agrupada:</strong> Muchas consultas densas</li>
                        <li><strong>Lineal degenerada:</strong> √çndices ineficientes</li>
                        <li><strong>Alta dimensionalidad:</strong> "Maldici√≥n dimensional"</li>
                        <li><strong>Extremadamente dispersa:</strong> B√∫squedas infructuosas</li>
                    </ul>
                    
                    <h5>üîß Mitigaciones:</h5>
                    <ul>
                        <li>Normalizaci√≥n y preprocesamiento</li>
                        <li>Selecci√≥n de estructura adecuada</li>
                        <li>Sampling para datasets masivos</li>
                        <li>Paralelizaci√≥n cuando sea posible</li>
                    </ul>
                </div>

                <div class="factor-card parameters-factor base-card">
                    <h4>‚öôÔ∏è Impacto de Par√°metros</h4>
                    
                    <h5>Efecto de Epsilon (Œµ):</h5>
                    <ul>
                        <li><strong>Œµ peque√±o:</strong> Pocas consultas, m√°s r√°pido</li>
                        <li><strong>Œµ grande:</strong> Muchos vecinos, m√°s lento</li>
                        <li><strong>Œµ desbalanceado:</strong> Consultas ineficientes</li>
                        <li><strong>Œµ adaptativo:</strong> Optimizaci√≥n din√°mica</li>
                    </ul>
                    
                    <h5>Efecto de MinPts:</h5>
                    <ul>
                        <li><strong>MinPts bajo:</strong> Menos verificaciones</li>
                        <li><strong>MinPts alto:</strong> M√°s comparaciones por punto</li>
                        <li><strong>Relaci√≥n con Œµ:</strong> Par√°metros interdependientes</li>
                        <li><strong>Optimizaci√≥n conjunta:</strong> Balance cr√≠tico</li>
                    </ul>
                    
                    <h5>Estrategias de Optimizaci√≥n:</h5>
                    <ul>
                        <li>An√°lisis exploratorio para Œµ √≥ptimo</li>
                        <li>Heur√≠sticas dimensi√≥n-dependientes</li>
                        <li>Validaci√≥n cruzada para par√°metros</li>
                        <li>Monitoreo de rendimiento en producci√≥n</li>
                    </ul>
                </div>
            </div>

            <div class="comparison-section base-card">
                <h4>üìä Comparaci√≥n de Escalabilidad</h4>
                
                <div class="scaling-examples">
                    <div class="scaling-example">
                        <h5>Dataset Peque√±o (1,000 puntos):</h5>
                        <ul>
                            <li><strong>O(N¬≤):</strong> 1M operaciones, ~2 segundos</li>
                            <li><strong>O(N log N):</strong> 10K operaciones, ~0.02 segundos</li>
                            <li><strong>Diferencia:</strong> 100x m√°s r√°pido con √≠ndices</li>
                        </ul>
                    </div>
                    
                    <div class="scaling-example">
                        <h5>Dataset Mediano (10,000 puntos):</h5>
                        <ul>
                            <li><strong>O(N¬≤):</strong> 100M operaciones, ~200 segundos</li>
                            <li><strong>O(N log N):</strong> 130K operaciones, ~0.3 segundos</li>
                            <li><strong>Diferencia:</strong> 650x m√°s r√°pido con √≠ndices</li>
                        </ul>
                    </div>
                    
                    <div class="scaling-example">
                        <h5>Dataset Grande (100,000 puntos):</h5>
                        <ul>
                            <li><strong>O(N¬≤):</strong> 10B operaciones, ~5 horas</li>
                            <li><strong>O(N log N):</strong> 1.7M operaciones, ~5 segundos</li>
                            <li><strong>Diferencia:</strong> 3600x m√°s r√°pido con √≠ndices</li>
                        </ul>
                    </div>
                </div>
            </div>

            <div class="practical-examples base-card">
                <h4>üè≠ Ejemplos Pr√°cticos de Rendimiento</h4>
                
                <div class="examples-grid">
                    <div class="example-card">
                        <h5>üó∫Ô∏è Datos Geogr√°ficos</h5>
                        <p><strong>Dataset:</strong> 1M puntos GPS de taxis</p>
                        <p><strong>Implementaci√≥n:</strong> R-tree + DBSCAN optimizado</p>
                        <p><strong>Complejidad:</strong> O(N log N)</p>
                        <p><strong>Tiempo:</strong> ~3 minutos</p>
                        <p><strong>Memoria:</strong> 250MB</p>
                        <p><strong>Uso:</strong> Detecci√≥n de zonas de alta demanda</p>
                    </div>
                    
                    <div class="example-card">
                        <h5>üß¨ An√°lisis Gen√≥mico</h5>
                        <p><strong>Dataset:</strong> 100K secuencias de ADN</p>
                        <p><strong>Implementaci√≥n:</strong> M√©trica personalizada + KD-tree</p>
                        <p><strong>Complejidad:</strong> O(N log N)</p>
                        <p><strong>Tiempo:</strong> ~45 segundos</p>
                        <p><strong>Memoria:</strong> 80MB</p>
                        <p><strong>Uso:</strong> Clasificaci√≥n de variantes gen√©ticas</p>
                    </div>
                    
                    <div class="example-card">
                        <h5>üìä Procesamiento de Im√°genes</h5>
                        <p><strong>Dataset:</strong> 500K p√≠xeles de imagen m√©dica</p>
                        <p><strong>Implementaci√≥n:</strong> Sin √≠ndice (implementaci√≥n naive)</p>
                        <p><strong>Complejidad:</strong> O(N¬≤)</p>
                        <p><strong>Tiempo:</strong> ~2 horas</p>
                        <p><strong>Memoria:</strong> 400MB</p>
                        <p><strong>Problema:</strong> Implementaci√≥n no optimizada</p>
                    </div>
                    
                    <div class="example-card">
                        <h5>üè™ Segmentaci√≥n de Clientes</h5>
                        <p><strong>Dataset:</strong> 50K perfiles de usuarios</p>
                        <p><strong>Implementaci√≥n:</strong> Scikit-learn (autom√°ticamente optimizada)</p>
                        <p><strong>Complejidad:</strong> O(N log N)</p>
                        <p><strong>Tiempo:</strong> ~8 segundos</p>
                        <p><strong>Memoria:</strong> 25MB</p>
                        <p><strong>Uso:</strong> Marketing personalizado</p>
                    </div>
                </div>
            </div>

            <div class="optimization-section base-card">
                <h4>üöÄ Gu√≠a de Optimizaci√≥n Pr√°ctica</h4>
                
                <div class="optimization-steps">
                    <div class="step">
                        <span class="step-number">1</span>
                        <div class="step-content">
                            <h5>Selecci√≥n de Estructura de Datos</h5>
                            <ul>
                                <li><strong>2D-4D:</strong> KD-tree (m√°s eficiente)</li>
                                <li><strong>Geogr√°ficos:</strong> R-tree o Quad-tree</li>
                                <li><strong>Alta dimensionalidad:</strong> Ball-tree</li>
                                <li><strong>Datasets <1K:</strong> Brute-force acceptable</li>
                            </ul>
                        </div>
                    </div>
                    
                    <div class="step">
                        <span class="step-number">2</span>
                        <div class="step-content">
                            <h5>Optimizaci√≥n de Par√°metros</h5>
                            <ul>
                                <li><strong>Œµ conservador:</strong> Valores menores = menos operaciones</li>
                                <li><strong>MinPts balanceado:</strong> Evitar extremos</li>
                                <li><strong>Normalizaci√≥n:</strong> Mejorar distribuci√≥n espacial</li>
                                <li><strong>Sampling:</strong> Para datasets >1M puntos</li>
                            </ul>
                        </div>
                    </div>
                    
                    <div class="step">
                        <span class="step-number">3</span>
                        <div class="step-content">
                            <h5>Consideraciones de Implementaci√≥n</h5>
                            <ul>
                                <li><strong>Librer√≠as optimizadas:</strong> Scikit-learn, WEKA</li>
                                <li><strong>Paralelizaci√≥n:</strong> Para datasets masivos</li>
                                <li><strong>Gesti√≥n de memoria:</strong> Evitar copias innecesarias</li>
                                <li><strong>Profiling:</strong> Identificar cuellos de botella</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>

            <div class="highlight-box base-card">
                <h4>üéØ Factores Clave que Determinan la Complejidad</h4>
                <p><strong>La complejidad temporal de DBSCAN no es fija</strong> y depende cr√≠ticamente de varios factores interrelacionados:</p>
                <div class="key-factors">
                    <div class="key-factor">
                        <h5>üèóÔ∏è Estructura de Indexaci√≥n</h5>
                        <p>El factor m√°s importante. √çndices espaciales pueden reducir la complejidad de O(N¬≤) a O(N log N).</p>
                    </div>
                    
                    <div class="key-factor">
                        <h5>üìä Distribuci√≥n de Datos</h5>
                        <p>Datos degenerados o mal distribuidos pueden degradar el rendimiento incluso con √≠ndices.</p>
                    </div>
                    
                    <div class="key-factor">
                        <h5>‚öôÔ∏è Par√°metros del Algoritmo</h5>
                        <p>Œµ y MinPts afectan directamente el n√∫mero de operaciones de vecindario realizadas.</p>
                    </div>
                    
                    <div class="key-factor">
                        <h5>üìê Dimensionalidad</h5>
                        <p>Espacios de alta dimensi√≥n complican la indexaci√≥n y pueden requerir estructuras especializadas.</p>
                    </div>
                    
                    <div class="key-factor">
                        <h5>üíª Calidad de Implementaci√≥n</h5>
                        <p>Las optimizaciones de bajo nivel y algoritmos auxiliares marcan una gran diferencia.</p>
                    </div>
                </div>
            </div>

            <div class="answer-section">
                <h3>üìù Resumen Ejecutivo</h3>
                
                <h4>üéØ Complejidad Temporal de DBSCAN:</h4>
                <ul>
                    <li><strong>Mejor caso:</strong> O(N log N) con √≠ndices espaciales eficientes</li>
                    <li><strong>Peor caso:</strong> O(N¬≤) sin estructuras de indexaci√≥n</li>
                    <li><strong>Caso pr√°ctico:</strong> O(N log N) con implementaciones modernas</li>
                </ul>

                <h4>üèóÔ∏è Factores Determinantes:</h4>
                <ul>
                    <li><strong>Estructura de datos:</strong> KD-tree, R-tree vs b√∫squeda naive</li>
                    <li><strong>Distribuci√≥n de datos:</strong> Uniforme vs degenerada</li>
                    <li><strong>Par√°metros:</strong> Valores de Œµ y MinPts</li>
                    <li><strong>Implementaci√≥n:</strong> Optimizada vs naive</li>
                </ul>

                <h4>üí° Recomendaci√≥n Pr√°ctica:</h4>
                <p><strong>Para uso real:</strong> Utilizar implementaciones optimizadas como scikit-learn que autom√°ticamente seleccionan estructuras de indexaci√≥n apropiadas y alcanzan O(N log N) en la mayor√≠a de casos pr√°cticos, evitando implementaciones naive que resultan en O(N¬≤).</p>
            </div>
            
            <div class="back-button-container">
                <button class="back-button" onclick="history.back()">
                    Volver a la p√°gina anterior
                </button>
            </div>
        </div>
    </div>

    <script src="dbscan_q8.js"></script>
</body>
</html>