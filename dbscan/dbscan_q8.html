<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DBSCAN Pregunta 8: Complejidad Temporal</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <link rel="stylesheet" href="dbscan.css">
</head>
<body>
    <div class="container">
        <div class="header q8">
            <h1>DBSCAN: Pregunta 8</h1>
            <p>¬øCu√°l es la Complejidad Temporal del Algoritmo DBSCAN?</p>
        </div>
        
        <div class="content">
            <div class="question-box q8">
                <h2>¬øCu√°l es la complejidad temporal del algoritmo DBSCAN?</h2>
                <p><strong>Contexto:</strong> La complejidad temporal determina qu√© tan eficiente es el algoritmo conforme aumenta el tama√±o del dataset y depende de las estructuras de datos utilizadas.</p>
            </div>

            <div class="answer-section">
                <h3>Respuesta: La complejidad temporal var√≠a seg√∫n la implementaci√≥n</h3>
                <p><strong>Mejor caso:</strong> O(N log N) con estructuras de indexaci√≥n espacial</p>
                <p><strong>Caso promedio:</strong> Depende de los datos y la implementaci√≥n</p>
                <p><strong>Peor caso:</strong> O(N¬≤) sin estructuras de indexaci√≥n o datos degenerados</p>
            </div>

            <div class="complexity-grid">
                <div class="complexity-card best-case">
                    <h4>üü¢ Mejor Caso: O(N log N)</h4>
                    <div class="formula-display">
                        O(N log N)
                    </div>
                    <p><strong>Condiciones:</strong></p>
                    <ul>
                        <li>Uso de √≠ndices espaciales (KD-tree, R-tree)</li>
                        <li>Consultas de vecindario en tiempo logar√≠tmico</li>
                        <li>Datos bien distribuidos</li>
                        <li>Implementaci√≥n optimizada</li>
                    </ul>
                    <p><strong>Escenario ideal:</strong> Datasets grandes con estructura espacial eficiente</p>
                </div>

                <div class="complexity-card worst-case">
                    <h4>üî¥ Peor Caso: O(N¬≤)</h4>
                    <div class="formula-display">
                        O(N¬≤)
                    </div>
                    <p><strong>Condiciones:</strong></p>
                    <ul>
                        <li>Sin estructuras de indexaci√≥n</li>
                        <li>Datos degenerados o muy densos</li>
                        <li>Consultas de vecindario lineales</li>
                        <li>Implementaci√≥n naive</li>
                    </ul>
                    <p><strong>Escenario problem√°tico:</strong> B√∫squeda exhaustiva de vecinos para cada punto</p>
                </div>

                <div class="complexity-card average-case">
                    <h4>üü° Caso Promedio: Variable</h4>
                    <div class="formula-display">
                        O(N log N) ‚Üî O(N¬≤)
                    </div>
                    <p><strong>Factores determinantes:</strong></p>
                    <ul>
                        <li>Distribuci√≥n de los datos</li>
                        <li>Valores de Œµ y MinPts</li>
                        <li>Estructuras de datos utilizadas</li>
                        <li>Calidad de la implementaci√≥n</li>
                    </ul>
                    <p><strong>Realidad pr√°ctica:</strong> Depende heavily de la implementaci√≥n espec√≠fica</p>
                </div>
            </div>

            <div class="demo-section">
                <h3>üéÆ Demostraci√≥n Interactiva: Impacto de la Complejidad</h3>
                <p>Observa c√≥mo diferentes tama√±os de dataset afectan el tiempo de ejecuci√≥n:</p>
                
                <div class="controls">
                    <div class="control-group">
                        <label>Tama√±o Dataset (N)</label>
                        <input type="range" id="dataset-size" min="100" max="2000" value="500" step="100">
                        <span id="size-value">500</span> puntos
                    </div>
                    <div class="control-group">
                        <label>Tipo de Implementaci√≥n</label>
                        <select id="implementation-type">
                            <option value="indexed">Con √çndice Espacial (KD-tree)</option>
                            <option value="naive">Sin √çndice (B√∫squeda Naive)</option>
                            <option value="optimized">Optimizada (Scikit-learn)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Epsilon (Œµ)</label>
                        <input type="range" id="eps-slider" min="20" max="80" value="40" step="10">
                        <span id="eps-value">40</span>
                    </div>
                </div>
                
                <svg id="complexity-demo" width="650" height="400"></svg>
                
                <div class="stats-display">
                    <div class="stat-item">
                        <div class="stat-value" id="current-size">500</div>
                        <div class="stat-label">Puntos (N)</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="complexity-order">O(N log N)</div>
                        <div class="stat-label">Complejidad</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="estimated-ops">4,500</div>
                        <div class="stat-label">Operaciones Est.</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="execution-time">45ms</div>
                        <div class="stat-label">Tiempo Est.</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="memory-usage">2.4MB</div>
                        <div class="stat-label">Memoria Est.</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="scalability-rating">Excelente</div>
                        <div class="stat-label">Escalabilidad</div>
                    </div>
                </div>
            </div>

            <div class="comparison-section">
                <h3>üìä Comparaci√≥n de Complejidades</h3>
                <svg id="complexity-comparison" width="650" height="300"></svg>
                <p><small>Gr√°fico mostrando c√≥mo escala cada implementaci√≥n con el tama√±o del dataset</small></p>
            </div>

            <div class="factors-grid">
                <div class="factor-card indexing-factor">
                    <h4>üå≥ Estructuras de Indexaci√≥n Espacial</h4>
                    <p><strong>KD-Tree (K-Dimensional Tree):</strong></p>
                    <ul>
                        <li>B√∫squeda de vecinos en O(log N)</li>
                        <li>Eficiente para dimensiones < 10</li>
                        <li>Partici√≥n recursiva del espacio</li>
                        <li>Memoria adicional: O(N)</li>
                    </ul>
                    <p><strong>R-Tree (Rectangle Tree):</strong></p>
                    <ul>
                        <li>Optimizado para consultas espaciales</li>
                        <li>Maneja regiones rectangulares</li>
                        <li>Mejor para datos geogr√°ficos</li>
                        <li>Complejidad: O(log N) por consulta</li>
                    </ul>
                </div>

                <div class="factor-card implementation-factor">
                    <h4>‚öôÔ∏è Factores de Implementaci√≥n</h4>
                    <p><strong>Algoritmo Naive:</strong></p>
                    <ul>
                        <li>B√∫squeda exhaustiva O(N) por punto</li>
                        <li>Complejidad total: O(N¬≤)</li>
                        <li>Simple pero ineficiente</li>
                        <li>No escalable para datasets grandes</li>
                    </ul>
                    <p><strong>Implementaci√≥n Optimizada:</strong></p>
                    <ul>
                        <li>Uso de estructuras de datos eficientes</li>
                        <li>T√©cnicas de poda y optimizaci√≥n</li>
                        <li>Paralelizaci√≥n cuando es posible</li>
                        <li>Gesti√≥n inteligente de memoria</li>
                    </ul>
                </div>

                <div class="factor-card data-factor">
                    <h4>üìà Caracter√≠sticas de los Datos</h4>
                    <p><strong>Distribuci√≥n Espacial:</strong></p>
                    <ul>
                        <li>Datos bien distribuidos: Mejor rendimiento</li>
                        <li>Datos agrupados: Puede degradar performance</li>
                        <li>Dimensionalidad: Afecta eficiencia de √≠ndices</li>
                        <li>Densidad variable: Impacta consultas</li>
                    </ul>
                    <p><strong>Par√°metros DBSCAN:</strong></p>
                    <ul>
                        <li>Œµ peque√±o: Menos vecinos, m√°s r√°pido</li>
                        <li>Œµ grande: M√°s vecinos, m√°s lento</li>
                        <li>MinPts: Afecta n√∫mero de iteraciones</li>
                        <li>Forma de clusters: Influye en expansi√≥n</li>
                    </ul>
                </div>
            </div>

            <div class="practical-examples">
                <h3>üè≠ Ejemplos Pr√°cticos de Rendimiento</h3>
                <div class="example-grid">
                    <div class="example-card">
                        <h6>üó∫Ô∏è Datos Geogr√°ficos</h6>
                        <p><strong>Dataset:</strong> 1M puntos GPS</p>
                        <p><strong>Implementaci√≥n:</strong> R-tree + DBSCAN optimizado</p>
                        <p><strong>Complejidad:</strong> O(N log N)</p>
                        <p><strong>Tiempo:</strong> ~3 minutos</p>
                        <p><strong>Memoria:</strong> 250MB</p>
                    </div>
                    
                    <div class="example-card">
                        <h6>üß¨ Datos Gen√≥micos</h6>
                        <p><strong>Dataset:</strong> 100K secuencias</p>
                        <p><strong>Implementaci√≥n:</strong> M√©trica personalizada + KD-tree</p>
                        <p><strong>Complejidad:</strong> O(N log N)</p>
                        <p><strong>Tiempo:</strong> ~45 segundos</p>
                        <p><strong>Memoria:</strong> 80MB</p>
                    </div>
                    
                    <div class="example-card">
                        <h6>üìä An√°lisis de Im√°genes</h6>
                        <p><strong>Dataset:</strong> 50K p√≠xeles</p>
                        <p><strong>Implementaci√≥n:</strong> Sin √≠ndice (naive)</p>
                        <p><strong>Complejidad:</strong> O(N¬≤)</p>
                        <p><strong>Tiempo:</strong> ~8 minutos</p>
                        <p><strong>Memoria:</strong> 400MB</p>
                    </div>
                    
                    <div class="example-card">
                        <h6>üè™ Segmentaci√≥n Clientes</h6>
                        <p><strong>Dataset:</strong> 10K usuarios</p>
                        <p><strong>Implementaci√≥n:</strong> Scikit-learn optimizada</p>
                        <p><strong>Complejidad:</strong> O(N log N)</p>
                        <p><strong>Tiempo:</strong> ~2 segundos</p>
                        <p><strong>Memoria:</strong> 15MB</p>
                    </div>
                </div>
            </div>

            <div class="optimization-tips">
                <h3>üöÄ Consejos de Optimizaci√≥n</h3>
                
                <h4>1. Selecci√≥n de Estructura de Datos:</h4>
                <ul>
                    <li><strong>Dimensiones bajas (2D-4D):</strong> Usar KD-tree</li>
                    <li><strong>Datos geogr√°ficos:</strong> Usar R-tree o Quad-tree</li>
                    <li><strong>Alta dimensionalidad:</strong> Considerar Ball-tree</li>
                    <li><strong>Datasets peque√±os:</strong> B√∫squeda brute-force puede ser suficiente</li>
                </ul>

                <h4>2. Optimizaci√≥n de Par√°metros:</h4>
                <ul>
                    <li><strong>Œµ conservador:</strong> Valores m√°s peque√±os = menos vecinos = m√°s r√°pido</li>
                    <li><strong>MinPts apropiado:</strong> Evitar valores extremadamente altos</li>
                    <li><strong>Preprocesamiento:</strong> Normalizar datos para mejor distribuci√≥n</li>
                    <li><strong>Sampling:</strong> Usar muestras para datasets masivos</li>
                </ul>

                <h4>3. Consideraciones de Implementaci√≥n:</h4>
                <ul>
                    <li><strong>Paralelizaci√≥n:</strong> Aprovechar m√∫ltiples cores cuando sea posible</li>
                    <li><strong>Gesti√≥n de memoria:</strong> Evitar copias innecesarias de datos</li>
                    <li><strong>Algoritmos aproximados:</strong> Para datasets extremadamente grandes</li>
                    <li><strong>Librer√≠as optimizadas:</strong> Usar implementaciones profesionales (scikit-learn)</li>
                </ul>
            </div>

            <div class="highlight-box">
                <h4>Factores Clave que Determinan la Complejidad</h4>
                <p><strong>La complejidad temporal de DBSCAN no es fija</strong> y depende cr√≠ticalment</p>
                <ul>
                    <li><strong>Estructura de indexaci√≥n:</strong> El factor m√°s importante para la eficiencia</li>
                    <li><strong>Distribuci√≥n de datos:</strong> Datos degenerados pueden degradar el rendimiento</li>
                    <li><strong>Par√°metros del algoritmo:</strong> Œµ y MinPts afectan el n√∫mero de operaciones</li>
                    <li><strong>Dimensionalidad:</strong> Espacios de alta dimensi√≥n complican la indexaci√≥n</li>
                    <li><strong>Calidad de implementaci√≥n:</strong> Las optimizaciones marcan gran diferencia</li>
                </ul>
            </div>

            <div class="answer-section">
                <h3>üìù Resumen Ejecutivo</h3>
                
                <h4>üéØ Complejidad Temporal de DBSCAN:</h4>
                <ul>
                    <li><strong>Mejor caso:</strong> O(N log N) con √≠ndices espaciales eficientes</li>
                    <li><strong>Peor caso:</strong> O(N¬≤) sin estructuras de indexaci√≥n</li>
                    <li><strong>Caso pr√°ctico:</strong> Generalmente O(N log N) con implementaciones modernas</li>
                </ul>

                <h4>üèóÔ∏è Factores Determinantes:</h4>
                <ul>
                    <li><strong>Estructura de datos:</strong> KD-tree, R-tree vs b√∫squeda naive</li>
                    <li><strong>Distribuci√≥n de datos:</strong> Uniforme vs degenerada</li>
                    <li><strong>Par√°metros:</strong> Valores de Œµ y MinPts</li>
                    <li><strong>Implementaci√≥n:</strong> Optimizada vs naive</li>
                </ul>

                <h4>üí° Recomendaci√≥n Pr√°ctica:</h4>
                <p><strong>Para uso real:</strong> Usar implementaciones optimizadas como scikit-learn que alcanzan O(N log N) en la mayor√≠a de casos pr√°cticos, evitando implementaciones naive que resultan en O(N¬≤).</p>
            </div>
        </div>
        
        <div class="back-button-container">
            <button class="back-button" onclick="history.back()">
                Volver a la p√°gina anterior
            </button>
        </div>
    </div>

    <script src="dbscan_q8.js"></script>
</body>
</html>