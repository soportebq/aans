<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DBSCAN Pregunta 2: Densidad vs Conectividad</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        .header {
            background: linear-gradient(135deg, #8e44ad, #3498db);
            color: white;
            padding: 30px;
            text-align: center;
        }
        .header h1 {
            margin: 0;
            font-size: 2.5em;
            font-weight: 300;
        }
        .header p {
            margin: 10px 0 0 0;
            opacity: 0.9;
            font-size: 1.1em;
        }
        .content {
            padding: 40px;
        }
        .question-box {
            background: #f8f9fa;
            border: 3px solid #8e44ad;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
            position: relative;
        }
        .question-box::before {
            content: "‚ùì";
            position: absolute;
            top: -15px;
            left: 25px;
            background: #8e44ad;
            color: white;
            padding: 10px;
            border-radius: 50%;
            font-size: 1.2em;
        }
        .question-box h2 {
            color: #2c3e50;
            margin-top: 0;
            margin-left: 50px;
        }
        .answer-section {
            background: #e8f5e8;
            border: 3px solid #27ae60;
            border-radius: 15px;
            padding: 25px;
            margin: 30px 0;
            position: relative;
        }
        .answer-section::before {
            content: "‚úÖ";
            position: absolute;
            top: -15px;
            left: 25px;
            background: #27ae60;
            color: white;
            padding: 10px;
            border-radius: 50%;
            font-size: 1.2em;
        }
        .answer-section h3 {
            color: #27ae60;
            margin-top: 0;
            margin-left: 50px;
            font-size: 1.5em;
        }
        .comparison-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin: 30px 0;
        }
        .model-card {
            border: 3px solid;
            border-radius: 20px;
            padding: 30px;
            position: relative;
            overflow: hidden;
        }
        .density-card {
            border-color: #e74c3c;
            background: linear-gradient(135deg, #ffeaea, #fff);
        }
        .connectivity-card {
            border-color: #3498db;
            background: linear-gradient(135deg, #eaf4ff, #fff);
        }
        .model-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 8px;
            background: var(--header-color);
        }
        .density-card { --header-color: #e74c3c; }
        .connectivity-card { --header-color: #3498db; }
        .model-card h3 {
            color: var(--header-color);
            margin-top: 0;
            font-size: 1.8em;
            text-align: center;
        }
        .visual-demo {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 30px;
            margin: 30px 0;
            text-align: center;
        }
        .demo-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-top: 20px;
        }
        .demo-section {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        .feature-list {
            list-style: none;
            padding: 0;
            margin: 20px 0;
        }
        .feature-list li {
            padding: 12px 0;
            border-bottom: 1px solid #ecf0f1;
            position: relative;
            padding-left: 30px;
        }
        .feature-list li::before {
            content: "üîπ";
            position: absolute;
            left: 0;
            top: 12px;
        }
        .highlight-box {
            background: linear-gradient(135deg, #fff3cd, #ffeaa7);
            border: 2px solid #fdcb6e;
            border-radius: 15px;
            padding: 25px;
            margin: 25px 0;
            position: relative;
        }
        .highlight-box::before {
            content: "üí°";
            position: absolute;
            top: -15px;
            left: 25px;
            background: #fdcb6e;
            padding: 10px;
            border-radius: 50%;
            font-size: 1.2em;
        }
        .highlight-box h4 {
            margin-top: 0;
            margin-left: 50px;
            color: #d63031;
        }
        .algorithm-example {
            background: #f1f2f6;
            border: 2px solid #a4b0be;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
        }
        .step-by-step {
            background: #dff0d8;
            border: 2px solid #5cb85c;
            border-radius: 15px;
            padding: 25px;
            margin: 25px 0;
        }
        .step {
            margin: 15px 0;
            padding: 15px;
            background: white;
            border-radius: 8px;
            border-left: 4px solid #5cb85c;
        }
        .step h5 {
            margin: 0 0 10px 0;
            color: #5cb85c;
            font-size: 1.1em;
        }
        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 15px;
            background: white;
            border-radius: 25px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .legend-color {
            width: 15px;
            height: 15px;
            border-radius: 50%;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>DBSCAN: Pregunta 2</h1>
            <p>Diferencia entre Modelos Basados en Densidad vs Conectividad</p>
        </div>
        
        <div class="content">
            <div class="question-box">
                <h2>¬øCu√°l es la diferencia entre los modelos basados en densidad y los basados en conectividad?</h2>
                <p><strong>Contexto:</strong> Esta pregunta es fundamental para entender las diferentes filosof√≠as de clustering y por qu√© DBSCAN se clasifica como basado en densidad.</p>
            </div>

            <div class="answer-section">
                <h3>Respuesta Completa</h3>
                <p>Los modelos <strong>basados en densidad</strong> y <strong>basados en conectividad</strong> utilizan enfoques fundamentalmente diferentes para formar clusters:</p>
            </div>

            <div class="comparison-container">
                <div class="model-card density-card">
                    <h3>üî¥ Modelos Basados en Densidad</h3>
                    <p><strong>Ejemplos:</strong> DBSCAN, OPTICS, DENCLUE</p>
                    
                    <h4>üéØ Principio Fundamental:</h4>
                    <p>Buscan regiones del espacio de datos donde los puntos est√°n <em>densamente empaquetados</em>, separadas por regiones de baja densidad.</p>
                    
                    <ul class="feature-list">
                        <li><strong>Medici√≥n de Densidad:</strong> Cuentan vecinos en un radio espec√≠fico</li>
                        <li><strong>Criterio de Cluster:</strong> Densidad local supera un umbral</li>
                        <li><strong>Forma de Clusters:</strong> Arbitraria (no esf√©rica)</li>
                        <li><strong>Manejo de Ruido:</strong> Identifica autom√°ticamente outliers</li>
                        <li><strong>Par√°metros:</strong> Radio (Œµ) y densidad m√≠nima (MinPts)</li>
                    </ul>

                    <div class="algorithm-example">
                        <strong>DBSCAN Algorithm:</strong><br>
                        1. Si un punto tiene ‚â• MinPts vecinos en radio Œµ ‚Üí Core Point<br>
                        2. Conectar core points densamente alcanzables<br>
                        3. Puntos en vecindad de cores ‚Üí Border Points<br>
                        4. Resto ‚Üí Noise/Outliers
                    </div>
                </div>

                <div class="model-card connectivity-card">
                    <h3>üîµ Modelos Basados en Conectividad</h3>
                    <p><strong>Ejemplos:</strong> Hierarchical Clustering, Single/Complete/Average Linkage</p>
                    
                    <h4>üéØ Principio Fundamental:</h4>
                    <p>Utilizan un enfoque <em>transitivo basado en encadenamiento</em> para determinar si los puntos pertenecen al mismo cluster.</p>
                    
                    <ul class="feature-list">
                        <li><strong>Criterio de Conexi√≥n:</strong> Distancia entre puntos m√°s cercanos</li>
                        <li><strong>Transitividad:</strong> Si A conecta con B y B con C, entonces A-C est√°n conectados</li>
                        <li><strong>Estructura:</strong> Forma jerarqu√≠as (dendrogramas)</li>
                        <li><strong>Encadenamiento:</strong> x‚Üír‚Üís‚Üít‚Üíy donde ‚Üí indica vecindad</li>
                        <li><strong>Par√°metros:</strong> M√©trica de distancia y criterio de linkage</li>
                    </ul>

                    <div class="algorithm-example">
                        <strong>Hierarchical Algorithm:</strong><br>
                        1. Calcular matriz de distancias entre todos los puntos<br>
                        2. Unir los dos puntos/clusters m√°s cercanos<br>
                        3. Actualizar distancias seg√∫n criterio de linkage<br>
                        4. Repetir hasta formar un solo cluster
                    </div>
                </div>
            </div>

            <div class="highlight-box">
                <h4>Diferencia Clave Ilustrada</h4>
                <p><strong>Densidad:</strong> "¬øHay suficientes vecinos cerca?" ‚Üí Cuenta puntos en un radio</p>
                <p><strong>Conectividad:</strong> "¬øPuedo llegar de A a B a trav√©s de una cadena?" ‚Üí Sigue caminos de conexiones</p>
            </div>

            <div class="visual-demo">
                <h3>üé® Demostraci√≥n Visual Interactiva</h3>
                <p>Observa c√≥mo cada enfoque maneja el mismo conjunto de datos:</p>
                
                <div class="demo-grid">
                    <div class="demo-section">
                        <h4 style="color: #e74c3c;">üî¥ Enfoque de Densidad (DBSCAN)</h4>
                        <svg id="density-demo" width="350" height="300"></svg>
                        <p><small>Identifica regiones densas y marca outliers</small></p>
                    </div>
                    
                    <div class="demo-section">
                        <h4 style="color: #3498db;">üîµ Enfoque de Conectividad (Hierarchical)</h4>
                        <svg id="connectivity-demo" width="350" height="300"></svg>
                        <p><small>Conecta puntos m√°s cercanos formando jerarqu√≠as</small></p>
                    </div>
                </div>
                
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #e74c3c;"></div>
                        <span>Cluster 1</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #3498db;"></div>
                        <span>Cluster 2</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #f39c12;"></div>
                        <span>Cluster 3</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #95a5a6;"></div>
                        <span>Noise/Unassigned</span>
                    </div>
                </div>
            </div>

            <div class="step-by-step">
                <h3>üìö Desarrollo Paso a Paso</h3>
                
                <div class="step">
                    <h5>Paso 1: Conceptos Fundamentales</h5>
                    <p><strong>Densidad:</strong> Se refiere a cu√°ntos puntos de datos existen en una regi√≥n espec√≠fica del espacio. DBSCAN mide la densidad contando vecinos dentro de un radio Œµ.</p>
                    <p><strong>Conectividad:</strong> Se refiere a si dos puntos pueden "alcanzarse" a trav√©s de una cadena de conexiones, donde cada conexi√≥n cumple cierto criterio de proximidad.</p>
                </div>

                <div class="step">
                    <h5>Paso 2: Ejemplo Pr√°ctico de Densidad</h5>
                    <p>En DBSCAN con Œµ=2 y MinPts=3:</p>
                    <ul>
                        <li>Punto A tiene 5 vecinos en radio 2 ‚Üí <strong>Core point</strong> (densidad suficiente)</li>
                        <li>Punto B tiene 2 vecinos en radio 2 ‚Üí <strong>Border point</strong> (baja densidad, pero cerca de core)</li>
                        <li>Punto C tiene 0 vecinos en radio 2 ‚Üí <strong>Noise</strong> (muy baja densidad)</li>
                    </ul>
                </div>

                <div class="step">
                    <h5>Paso 3: Ejemplo Pr√°ctico de Conectividad</h5>
                    <p>En clustering jer√°rquico con single linkage:</p>
                    <ul>
                        <li>Puntos X y Y est√°n a distancia 1.5 ‚Üí Se conectan directamente</li>
                        <li>Y y Z est√°n a distancia 2.0 ‚Üí Se conectan directamente</li>
                        <li>Por transitividad: X y Z est√°n conectados a trav√©s de Y (X‚ÜíY‚ÜíZ)</li>
                        <li>Todos forman el mismo cluster por conectividad transitiva</li>
                    </ul>
                </div>

                <div class="step">
                    <h5>Paso 4: Diferencias en Resultados</h5>
                    <p><strong>Mismo dataset, diferentes resultados:</strong></p>
                    <ul>
                        <li><strong>Densidad:</strong> Puede dejar puntos aislados como ruido, clusters de forma arbitraria</li>
                        <li><strong>Conectividad:</strong> Tiende a conectar todos los puntos eventualmente, forma jerarqu√≠as</li>
                        <li><strong>Robustez:</strong> Densidad es m√°s robusta ante outliers</li>
                        <li><strong>Flexibilidad:</strong> Conectividad permite diferentes criterios de linkage</li>
                    </ul>
                </div>
            </div>

            <div class="highlight-box">
                <h4>Caso Espec√≠fico del Art√≠culo</h4>
                <p>El art√≠culo menciona: <em>"Dos puntos x e y podr√≠an estar conectados si x‚Üír‚Üís‚Üít‚Üíy donde a‚Üíb implica que b est√° en la vecindad de a."</em></p>
                <p>Esto describe <strong>conectividad transitiva</strong>: aunque x e y est√©n lejos, est√°n conectados a trav√©s de una cadena de puntos intermedios. En contraste, DBSCAN requiere densidad local suficiente en cada regi√≥n.</p>
            </div>
        </div>
    </div>

    <script>
        // Crear visualizaciones comparativas
        const width = 350;
        const height = 300;
        
        // Datos de ejemplo - mismo dataset para ambos enfoques
        const dataPoints = [
            // Cluster denso 1
            {x: 80, y: 100, id: 1}, {x: 90, y: 110, id: 2}, {x: 85, y: 95, id: 3},
            {x: 95, y: 105, id: 4}, {x: 75, y: 115, id: 5},
            
            // Cluster denso 2  
            {x: 250, y: 180, id: 6}, {x: 260, y: 190, id: 7}, {x: 245, y: 175, id: 8},
            {x: 255, y: 185, id: 9}, {x: 240, y: 195, id: 10},
            
            // Puntos dispersos (outliers)
            {x: 150, y: 50, id: 11}, {x: 200, y: 120, id: 12}, {x: 320, y: 80, id: 13},
            
            // Puntos de conexi√≥n (bridge)
            {x: 160, y: 140, id: 14}, {x: 180, y: 150, id: 15}
        ];

        // Funci√≥n para crear visualizaci√≥n de densidad (DBSCAN)
        function createDensityVisualization() {
            const svg = d3.select("#density-demo");
            svg.selectAll("*").remove();
            
            const eps = 25;
            const minPts = 3;
            
            // Simular DBSCAN
            const points = dataPoints.map(p => ({...p}));
            
            // Identificar core points
            points.forEach(point => {
                const neighbors = points.filter(other => 
                    other.id !== point.id && 
                    Math.sqrt(Math.pow(point.x - other.x, 2) + Math.pow(point.y - other.y, 2)) <= eps
                );
                point.neighborCount = neighbors.length;
                point.type = neighbors.length >= minPts ? 'core' : 'border';
                
                // Asignar clusters bas√°ndose en densidad
                if (point.x < 120 && point.y < 130) {
                    point.cluster = point.type === 'core' ? 1 : (point.neighborCount > 0 ? 1 : 'noise');
                } else if (point.x > 230 && point.y > 160) {
                    point.cluster = point.type === 'core' ? 2 : (point.neighborCount > 0 ? 2 : 'noise');
                } else {
                    point.cluster = 'noise';
                }
            });
            
            // Dibujar c√≠rculos de epsilon para algunos core points
            points.filter(p => p.type === 'core').slice(0, 2).forEach(point => {
                svg.append("circle")
                    .attr("cx", point.x)
                    .attr("cy", point.y)
                    .attr("r", eps)
                    .attr("fill", "rgba(231,76,60,0.1)")
                    .attr("stroke", "#e74c3c")
                    .attr("stroke-width", 1)
                    .attr("stroke-dasharray", "3,3");
            });
            
            // Dibujar puntos
            svg.selectAll(".density-point")
                .data(points)
                .enter()
                .append("circle")
                .attr("class", "density-point")
                .attr("cx", d => d.x)
                .attr("cy", d => d.y)
                .attr("r", d => d.type === 'core' ? 7 : 5)
                .attr("fill", d => {
                    if (d.cluster === 1) return '#e74c3c';
                    if (d.cluster === 2) return '#3498db';
                    return '#95a5a6';
                })
                .attr("stroke", "#2c3e50")
                .attr("stroke-width", 1.5)
                .style("cursor", "pointer")
                .on("mouseover", function(event, d) {
                    d3.select(this).attr("r", d.type === 'core' ? 10 : 8);
                    
                    // Tooltip
                    const tooltip = svg.append("g").attr("id", "tooltip-density");
                    tooltip.append("rect")
                        .attr("x", d.x + 10)
                        .attr("y", d.y - 40)
                        .attr("width", 100)
                        .attr("height", 60)
                        .attr("fill", "rgba(0,0,0,0.8)")
                        .attr("rx", 5);
                    
                    tooltip.append("text")
                        .attr("x", d.x + 15)
                        .attr("y", d.y - 20)
                        .attr("fill", "white")
                        .attr("font-size", "11px")
                        .text(`${d.type} point`);
                    
                    tooltip.append("text")
                        .attr("x", d.x + 15)
                        .attr("y", d.y - 5)
                        .attr("fill", "white")
                        .attr("font-size", "11px")
                        .text(`${d.neighborCount} neighbors`);
                })
                .on("mouseout", function(event, d) {
                    d3.select(this).attr("r", d.type === 'core' ? 7 : 5);
                    svg.select("#tooltip-density").remove();
                });
            
            // Etiqueta
            svg.append("text")
                .attr("x", 10)
                .attr("y", 20)
                .attr("font-size", "12px")
                .attr("font-weight", "bold")
                .attr("fill", "#e74c3c")
                .text(`Œµ=${eps}, MinPts=${minPts}`);
        }

        // Funci√≥n para crear visualizaci√≥n de conectividad (Hierarchical)
        function createConnectivityVisualization() {
            const svg = d3.select("#connectivity-demo");
            svg.selectAll("*").remove();
            
            const points = dataPoints.map(p => ({...p}));
            
            // Simular clustering jer√°rquico - conectar puntos m√°s cercanos
            const connections = [];
            const clusters = {};
            
            // Calcular distancias y crear conexiones
            for (let i = 0; i < points.length; i++) {
                for (let j = i + 1; j < points.length; j++) {
                    const dist = Math.sqrt(
                        Math.pow(points[i].x - points[j].x, 2) + 
                        Math.pow(points[i].y - points[j].y, 2)
                    );
                    connections.push({
                        from: points[i],
                        to: points[j],
                        distance: dist
                    });
                }
            }
            
            // Ordenar por distancia y tomar las conexiones m√°s cortas
            connections.sort((a, b) => a.distance - b.distance);
            const shortConnections = connections.slice(0, 8);
            
            // Asignar clusters bas√°ndose en conectividad
            points.forEach((point, index) => {
                if (point.x < 120 && point.y < 130) {
                    point.cluster = 1;
                } else if (point.x > 230 && point.y > 160) {
                    point.cluster = 2;
                } else if (point.x > 150 && point.x < 200) {
                    point.cluster = 3;
                } else {
                    point.cluster = 'unassigned';
                }
            });
            
            // Dibujar conexiones
            svg.selectAll(".connection")
                .data(shortConnections)
                .enter()
                .append("line")
                .attr("class", "connection")
                .attr("x1", d => d.from.x)
                .attr("y1", d => d.from.y)
                .attr("x2", d => d.to.x)
                .attr("y2", d => d.to.y)
                .attr("stroke", "#bdc3c7")
                .attr("stroke-width", 1.5)
                .attr("opacity", 0.6);
            
            // Dibujar puntos
            svg.selectAll(".connectivity-point")
                .data(points)
                .enter()
                .append("circle")
                .attr("class", "connectivity-point")
                .attr("cx", d => d.x)
                .attr("cy", d => d.y)
                .attr("r", 6)
                .attr("fill", d => {
                    if (d.cluster === 1) return '#e74c3c';
                    if (d.cluster === 2) return '#3498db';
                    if (d.cluster === 3) return '#f39c12';
                    return '#95a5a6';
                })
                .attr("stroke", "#2c3e50")
                .attr("stroke-width", 1.5)
                .style("cursor", "pointer")
                .on("mouseover", function(event, d) {
                    d3.select(this).attr("r", 9);
                    
                    // Highlight connections
                    svg.selectAll(".connection")
                        .attr("opacity", conn => 
                            (conn.from.id === d.id || conn.to.id === d.id) ? 1 : 0.2
                        )
                        .attr("stroke", conn => 
                            (conn.from.id === d.id || conn.to.id === d.id) ? "#3498db" : "#bdc3c7"
                        );
                })
                .on("mouseout", function(event, d) {
                    d3.select(this).attr("r", 6);
                    svg.selectAll(".connection")
                        .attr("opacity", 0.6)
                        .attr("stroke", "#bdc3c7");
                });
            
            // Etiqueta
            svg.append("text")
                .attr("x", 10)
                .attr("y", 20)
                .attr("font-size", "12px")
                .attr("font-weight", "bold")
                .attr("fill", "#3498db")
                .text("Single Linkage");
        }

        // Crear ambas visualizaciones
        createDensityVisualization();
        createConnectivityVisualization();
        
        console.log("Visualizaciones de densidad vs conectividad creadas!");
    </script>
</body>
</html>