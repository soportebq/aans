<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DBSCAN Pregunta 3: Efectos del Par√°metro Epsilon</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        .container {
            max-width: 1300px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        .header {
            background: linear-gradient(135deg, #e74c3c, #f39c12);
            color: white;
            padding: 30px;
            text-align: center;
        }
        .header h1 {
            margin: 0;
            font-size: 2.5em;
            font-weight: 300;
        }
        .header p {
            margin: 10px 0 0 0;
            opacity: 0.9;
            font-size: 1.1em;
        }
        .content {
            padding: 40px;
        }
        .question-box {
            background: #f8f9fa;
            border: 3px solid #e74c3c;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
            position: relative;
        }
        .question-box::before {
            content: "‚ùì";
            position: absolute;
            top: -15px;
            left: 25px;
            background: #e74c3c;
            color: white;
            padding: 10px;
            border-radius: 50%;
            font-size: 1.2em;
        }
        .question-box h2 {
            color: #2c3e50;
            margin-top: 0;
            margin-left: 50px;
        }
        .answer-section {
            background: #e8f5e8;
            border: 3px solid #27ae60;
            border-radius: 15px;
            padding: 25px;
            margin: 30px 0;
            position: relative;
        }
        .answer-section::before {
            content: "‚úÖ";
            position: absolute;
            top: -15px;
            left: 25px;
            background: #27ae60;
            color: white;
            padding: 10px;
            border-radius: 50%;
            font-size: 1.2em;
        }
        .answer-section h3 {
            color: #27ae60;
            margin-top: 0;
            margin-left: 50px;
            font-size: 1.5em;
        }
        .epsilon-demo {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 25px;
            margin: 30px 0;
        }
        .epsilon-card {
            border: 3px solid;
            border-radius: 20px;
            padding: 25px;
            text-align: center;
            position: relative;
            overflow: hidden;
        }
        .epsilon-small {
            border-color: #e74c3c;
            background: linear-gradient(135deg, #ffebee, #fff);
        }
        .epsilon-optimal {
            border-color: #27ae60;
            background: linear-gradient(135deg, #e8f5e8, #fff);
        }
        .epsilon-large {
            border-color: #f39c12;
            background: linear-gradient(135deg, #fff3e0, #fff);
        }
        .epsilon-card h3 {
            color: var(--header-color);
            margin-top: 0;
            font-size: 1.4em;
        }
        .epsilon-small { --header-color: #e74c3c; }
        .epsilon-optimal { --header-color: #27ae60; }
        .epsilon-large { --header-color: #f39c12; }
        .interactive-demo {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 30px;
            margin: 30px 0;
            text-align: center;
        }
        .controls {
            margin: 20px 0;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
            background: white;
            padding: 10px 15px;
            border-radius: 25px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .control-group label {
            font-weight: bold;
            color: #2c3e50;
        }
        .control-group input[type="range"] {
            width: 150px;
        }
        .control-group input[type="number"] {
            width: 60px;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 15px;
            background: white;
            border-radius: 25px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .legend-color {
            width: 15px;
            height: 15px;
            border-radius: 50%;
        }
        .effects-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin: 30px 0;
        }
        .effect-card {
            border: 2px solid;
            border-radius: 15px;
            padding: 25px;
        }
        .small-epsilon { 
            border-color: #e74c3c; 
            background: linear-gradient(135deg, #ffebee, #fff);
        }
        .large-epsilon { 
            border-color: #f39c12; 
            background: linear-gradient(135deg, #fff3e0, #fff);
        }
        .effect-card h4 {
            color: var(--title-color);
            margin-top: 0;
            font-size: 1.3em;
            text-align: center;
        }
        .small-epsilon { --title-color: #e74c3c; }
        .large-epsilon { --title-color: #f39c12; }
        .consequences {
            list-style: none;
            padding: 0;
            margin: 20px 0;
        }
        .consequences li {
            padding: 10px 0;
            border-bottom: 1px solid #ecf0f1;
            position: relative;
            padding-left: 30px;
        }
        .consequences li::before {
            content: "‚ö†Ô∏è";
            position: absolute;
            left: 0;
            top: 10px;
        }
        .highlight-box {
            background: linear-gradient(135deg, #fff3cd, #ffeaa7);
            border: 3px solid #fdcb6e;
            border-radius: 15px;
            padding: 25px;
            margin: 25px 0;
            position: relative;
        }
        .highlight-box::before {
            content: "üí°";
            position: absolute;
            top: -15px;
            left: 25px;
            background: #fdcb6e;
            padding: 10px;
            border-radius: 50%;
            font-size: 1.2em;
        }
        .highlight-box h4 {
            margin-top: 0;
            margin-left: 50px;
            color: #d63031;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>DBSCAN: Pregunta 3</h1>
            <p>Efectos del Par√°metro Epsilon (Œµ) en el Clustering</p>
        </div>
        
        <div class="content">
            <div class="question-box">
                <h2>¬øQu√© pasa si el valor de epsilon (Œµ) es muy peque√±o o muy grande?</h2>
                <p><strong>Contexto:</strong> El par√°metro epsilon determina el radio de vecindad para cada punto. Su valor tiene un impacto cr√≠tico en los resultados del clustering.</p>
            </div>

            <div class="answer-section">
                <h3>Respuesta Completa</h3>
                <p>El valor de <strong>epsilon (Œµ)</strong> es uno de los par√°metros m√°s cr√≠ticos en DBSCAN. Valores inadecuados pueden resultar en clustering incorrecto:</p>
            </div>

            <div class="epsilon-demo">
                <div class="epsilon-card epsilon-small">
                    <h3>üî¥ Epsilon Muy Peque√±o</h3>
                    <svg id="small-epsilon" width="250" height="200"></svg>
                    <p><strong>Resultado:</strong> Clusters esparcidos son clasificados como ruido</p>
                    <p><em>Œµ = 15 (muy peque√±o)</em></p>
                </div>

                <div class="epsilon-card epsilon-optimal">
                    <h3>üü¢ Epsilon √ìptimo</h3>
                    <svg id="optimal-epsilon" width="250" height="200"></svg>
                    <p><strong>Resultado:</strong> Clusters correctamente identificados</p>
                    <p><em>Œµ = 35 (√≥ptimo)</em></p>
                </div>

                <div class="epsilon-card epsilon-large">
                    <h3>üü° Epsilon Muy Grande</h3>
                    <svg id="large-epsilon" width="250" height="200"></svg>
                    <p><strong>Resultado:</strong> Clusters separados se fusionan incorrectamente</p>
                    <p><em>Œµ = 80 (muy grande)</em></p>
                </div>
            </div>

            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #3498db;"></div>
                    <span>Cluster 1</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #e74c3c;"></div>
                    <span>Cluster 2</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #f39c12;"></div>
                    <span>Cluster 3</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #95a5a6;"></div>
                    <span>Ruido/Noise</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: rgba(52,152,219,0.2); border: 2px dashed #3498db;"></div>
                    <span>Radio Œµ</span>
                </div>
            </div>

            <div class="interactive-demo">
                <h3>üéÆ Demostraci√≥n Interactiva</h3>
                <p>Ajusta el valor de epsilon y observa c√≥mo cambia el clustering:</p>
                
                <div class="controls">
                    <div class="control-group">
                        <label>Epsilon (Œµ):</label>
                        <input type="range" id="epsilon-slider" min="10" max="100" value="35" step="5">
                        <input type="number" id="epsilon-input" min="10" max="100" value="35" step="5">
                    </div>
                    <div class="control-group">
                        <label>MinPts:</label>
                        <input type="number" id="minpts-input" min="2" max="8" value="3" step="1">
                    </div>
                </div>
                
                <svg id="interactive-demo" width="600" height="400"></svg>
                
                <div id="clustering-stats" style="margin-top: 20px; padding: 15px; background: white; border-radius: 10px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                    <strong>Estad√≠sticas actuales:</strong> <span id="stats-text">Epsilon: 35, Clusters: 2, Noise: 3</span>
                </div>
            </div>

            <div class="effects-grid">
                <div class="effect-card small-epsilon">
                    <h4>üî¥ Efectos de Epsilon Muy Peque√±o</h4>
                    <ul class="consequences">
                        <li><strong>Sobre-fragmentaci√≥n:</strong> Clusters v√°lidos se dividen en m√∫ltiples fragmentos</li>
                        <li><strong>Exceso de ruido:</strong> Muchos puntos se clasifican incorrectamente como outliers</li>
                        <li><strong>P√©rdida de estructura:</strong> Patrones reales en los datos no se detectan</li>
                        <li><strong>Clusters muy peque√±os:</strong> Solo los puntos m√°s densos forman clusters</li>
                        <li><strong>Baja recall:</strong> No se recuperan todos los puntos que deber√≠an estar en clusters</li>
                    </ul>
                </div>

                <div class="effect-card large-epsilon">
                    <h4>üü° Efectos de Epsilon Muy Grande</h4>
                    <ul class="consequences">
                        <li><strong>Sobre-agrupaci√≥n:</strong> Clusters distintos se fusionan incorrectamente</li>
                        <li><strong>P√©rdida de separaci√≥n:</strong> Se pierde la distinci√≥n entre grupos diferentes</li>
                        <li><strong>Clusters gigantes:</strong> La mayor√≠a de puntos se agrupan en pocos clusters grandes</li>
                        <li><strong>Poco ruido detectado:</strong> Outliers reales no se identifican</li>
                        <li><strong>Baja precisi√≥n:</strong> Puntos de diferentes grupos se mezclan</li>
                    </ul>
                </div>
            </div>

            <div class="highlight-box">
                <h4>Ejemplo Num√©rico Detallado</h4>
                <p><strong>Dataset:</strong> Puntos en un plano 2D con MinPts = 3</p>
                <ul>
                    <li><strong>Œµ = 10 (muy peque√±o):</strong> Solo puntos muy cercanos (< 10 unidades) son vecinos. Resultado: 8 clusters peque√±os + 15 puntos de ruido</li>
                    <li><strong>Œµ = 30 (√≥ptimo):</strong> Vecindad razonable. Resultado: 3 clusters bien definidos + 2 outliers reales</li>
                    <li><strong>Œµ = 80 (muy grande):</strong> Casi todos los puntos son vecinos. Resultado: 1 cluster gigante + 0 outliers</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        // Datos de ejemplo para las demostraciones
        const sampleData = [
            // Cluster 1 (izquierda)
            {x: 120, y: 150, id: 1}, {x: 130, y: 160, id: 2}, {x: 125, y: 140, id: 3},
            {x: 135, y: 155, id: 4}, {x: 115, y: 165, id: 5}, {x: 140, y: 145, id: 6},
            
            // Cluster 2 (derecha)
            {x: 380, y: 180, id: 7}, {x: 390, y: 190, id: 8}, {x: 375, y: 170, id: 9},
            {x: 385, y: 185, id: 10}, {x: 395, y: 175, id: 11}, {x: 370, y: 195, id: 12},
            
            // Cluster 3 (centro superior)
            {x: 250, y: 100, id: 13}, {x: 260, y: 110, id: 14}, {x: 245, y: 95, id: 15},
            {x: 255, y: 105, id: 16},
            
            // Puntos dispersos (potencial ruido)
            {x: 200, y: 250, id: 17}, {x: 450, y: 120, id: 18}, {x: 80, y: 80, id: 19}
        ];

        // Funci√≥n para simular DBSCAN
        function simulateDBSCAN(points, eps, minPts) {
            const result = points.map(p => ({...p, cluster: 'noise', neighbors: 0, isCore: false}));
            
            // Calcular vecinos y determinar core points
            result.forEach(point => {
                const neighbors = result.filter(other => 
                    other.id !== point.id && 
                    Math.sqrt(Math.pow(point.x - other.x, 2) + Math.pow(point.y - other.y, 2)) <= eps
                );
                point.neighbors = neighbors.length;
                point.isCore = neighbors.length >= minPts;
            });
            
            // Asignar clusters usando algoritmo simplificado
            let clusterIndex = 1;
            const visited = new Set();
            
            result.forEach(point => {
                if (point.isCore && !visited.has(point.id)) {
                    // Expandir cluster desde este core point
                    const queue = [point];
                    point.cluster = `cluster${clusterIndex}`;
                    visited.add(point.id);
                    
                    while (queue.length > 0) {
                        const current = queue.shift();
                        const neighbors = result.filter(other => 
                            other.id !== current.id && 
                            Math.sqrt(Math.pow(current.x - other.x, 2) + Math.pow(current.y - other.y, 2)) <= eps
                        );
                        
                        neighbors.forEach(neighbor => {
                            if (!visited.has(neighbor.id)) {
                                visited.add(neighbor.id);
                                neighbor.cluster = `cluster${clusterIndex}`;
                                if (neighbor.isCore) {
                                    queue.push(neighbor);
                                }
                            }
                        });
                    }
                    clusterIndex++;
                }
            });
            
            return result;
        }

        // Funci√≥n para crear visualizaci√≥n est√°tica
        function createStaticVisualization(svgId, eps) {
            const svg = d3.select(`#${svgId}`);
            svg.selectAll("*").remove();
            
            const points = simulateDBSCAN(sampleData, eps, 3);
            const colors = {
                cluster1: '#3498db',
                cluster2: '#e74c3c', 
                cluster3: '#f39c12',
                cluster4: '#9b59b6',
                noise: '#95a5a6'
            };
            
            // Escala para ajustar al SVG
            const scale = 0.6;
            
            // Dibujar c√≠rculos de epsilon para algunos core points
            const corePoints = points.filter(p => p.isCore).slice(0, 2);
            corePoints.forEach(point => {
                svg.append("circle")
                    .attr("cx", point.x * scale)
                    .attr("cy", point.y * 0.7)
                    .attr("r", eps * scale)
                    .attr("fill", "rgba(52,152,219,0.1)")
                    .attr("stroke", "#3498db")
                    .attr("stroke-width", 1)
                    .attr("stroke-dasharray", "2,2")
                    .attr("opacity", 0.7);
            });
            
            // Dibujar puntos
            svg.selectAll(".static-point")
                .data(points)
                .enter()
                .append("circle")
                .attr("class", "static-point")
                .attr("cx", d => d.x * scale)
                .attr("cy", d => d.y * 0.7)
                .attr("r", d => d.isCore ? 6 : 4)
                .attr("fill", d => colors[d.cluster] || colors.noise)
                .attr("stroke", "#2c3e50")
                .attr("stroke-width", 1.5);
            
            // Mostrar estad√≠sticas
            const clusterCount = new Set(points.filter(p => p.cluster !== 'noise').map(p => p.cluster)).size;
            const noiseCount = points.filter(p => p.cluster === 'noise').length;
            
            svg.append("text")
                .attr("x", 10)
                .attr("y", 180)
                .attr("font-size", "11px")
                .attr("fill", "#2c3e50")
                .attr("font-weight", "bold")
                .text(`Clusters: ${clusterCount}, Noise: ${noiseCount}`);
        }

        // Funci√≥n para actualizar la demostraci√≥n interactiva
        function updateClustering() {
            const eps = parseInt(document.getElementById('epsilon-slider').value);
            const minPts = parseInt(document.getElementById('minpts-input').value);
            
            const svg = d3.select("#interactive-demo");
            svg.selectAll("*").remove();
            
            const points = simulateDBSCAN(sampleData, eps, minPts);
            const colors = {
                cluster1: '#3498db',
                cluster2: '#e74c3c', 
                cluster3: '#f39c12',
                cluster4: '#9b59b6',
                cluster5: '#1abc9c',
                noise: '#95a5a6'
            };
            
            // Dibujar c√≠rculos de epsilon para core points
            const corePoints = points.filter(p => p.isCore);
            corePoints.forEach(point => {
                svg.append("circle")
                    .attr("cx", point.x)
                    .attr("cy", point.y)
                    .attr("r", eps)
                    .attr("fill", "rgba(52,152,219,0.05)")
                    .attr("stroke", "#3498db")
                    .attr("stroke-width", 1)
                    .attr("stroke-dasharray", "3,3")
                    .attr("opacity", 0.6);
            });
            
            // Dibujar puntos
            svg.selectAll(".interactive-point")
                .data(points)
                .enter()
                .append("circle")
                .attr("class", "interactive-point")
                .attr("cx", d => d.x)
                .attr("cy", d => d.y)
                .attr("r", d => d.isCore ? 8 : 6)
                .attr("fill", d => colors[d.cluster] || colors.noise)
                .attr("stroke", "#2c3e50")
                .attr("stroke-width", 2)
                .style("cursor", "pointer")
                .on("mouseover", function(event, d) {
                    d3.select(this).attr("r", d.isCore ? 12 : 9);
                    
                    const tooltip = svg.append("g").attr("id", "tooltip");
                    tooltip.append("rect")
                        .attr("x", d.x + 15)
                        .attr("y", d.y - 50)
                        .attr("width", 140)
                        .attr("height", 70)
                        .attr("fill", "rgba(0,0,0,0.9)")
                        .attr("rx", 8);
                    
                    tooltip.append("text")
                        .attr("x", d.x + 25)
                        .attr("y", d.y - 30)
                        .attr("fill", "white")
                        .attr("font-size", "12px")
                        .attr("font-weight", "bold")
                        .text(`${d.isCore ? 'Core' : 'Border/Noise'} Point`);
                    
                    tooltip.append("text")
                        .attr("x", d.x + 25)
                        .attr("y", d.y - 15)
                        .attr("fill", "white")
                        .attr("font-size", "11px")
                        .text(`Neighbors: ${d.neighbors}`);
                    
                    tooltip.append("text")
                        .attr("x", d.x + 25)
                        .attr("y", d.y)
                        .attr("fill", "white")
                        .attr("font-size", "11px")
                        .text(`Cluster: ${d.cluster}`);
                })
                .on("mouseout", function(event, d) {
                    d3.select(this).attr("r", d.isCore ? 8 : 6);
                    svg.select("#tooltip").remove();
                });
            
            // Actualizar estad√≠sticas
            const clusterCount = new Set(points.filter(p => p.cluster !== 'noise').map(p => p.cluster)).size;
            const noiseCount = points.filter(p => p.cluster === 'noise').length;
            
            document.getElementById('stats-text').textContent = 
                `Epsilon: ${eps}, MinPts: ${minPts}, Clusters: ${clusterCount}, Noise: ${noiseCount}`;
        }

        // Inicializar cuando el DOM est√© listo
        document.addEventListener('DOMContentLoaded', function() {
            // Crear visualizaciones est√°ticas
            createStaticVisualization('small-epsilon', 15);
            createStaticVisualization('optimal-epsilon', 35);
            createStaticVisualization('large-epsilon', 80);
            
            // Configurar controles interactivos
            const epsilonSlider = document.getElementById('epsilon-slider');
            const epsilonInput = document.getElementById('epsilon-input');
            const minptsInput = document.getElementById('minpts-input');
            
            // Sincronizar slider e input
            epsilonSlider.addEventListener('input', function() {
                epsilonInput.value = this.value;
                updateClustering();
            });
            
            epsilonInput.addEventListener('input', function() {
                if (this.value >= 10 && this.value <= 100) {
                    epsilonSlider.value = this.value;
                    updateClustering();
                }
            });
            
            minptsInput.addEventListener('input', function() {
                updateClustering();
            });
            
            // Crear demo interactiva inicial
            updateClustering();
            
            console.log("DBSCAN Epsilon Demo cargada correctamente!");
        });
    </script>
</body>
</html>